---
layout: encoraweekly
title: Home
---
<h1 class="center">Week 10 - What I learned</h1>
<p>This week in the academy program I had to do a lot of things that could be intimidating but I still keep going and learning. This week I had to my first contribution to an open-source project once again having nothing and reading other people's code. Also, this week was of a lot of learning and remembering things about computer science concepts and also learning soft skills in this case communication with others, people we don't know. This was quite an interesting week so let's get to it.</p>
<p>I'm going to share the main objectives of the week, what I did, talk a little more about the project I'm working on, what I had to do to get to my first contribution, and finally the results. I learn a lot of things this week, I will try to enum them here hope to put everything and don't forget something. </p>
<h2>Goals of the week.</h2>
<p>I think that the main goal was to understand the project that everyone is working on and try to find a way to solve an issue. In my case working with the vulnerable app I chose a big issue, which is adding new whole functionality from the ground, this means that I had to design a new level and find use cases and find the way to code it. That's personally from my project.</p>
<p>On the other hand, I had to answer some questions about other languages installing the environment and answering from the code.</p>
<p>Finally other of the goals of the week was trying to remember concepts for a mock interview, computer science concepts that I used to know but I forgot so I just need to go over them again and that's all.</p>


<h2>Open-source</h2>
<p>As I said I chose a big issue, I mean I don't mind I like the application, the purpose of the application, and the things that I have to do to solve the problem. Here is the issue:</p>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/issue.png'}}" alt="how">
<p>To do this I need to:</p>
<ul>
  <li>Understand the vulnerability that I'm going to work on, in this case, the SSRF vulnerability.</li>
  <li>Try to find a use case where the vulnerability could arise.</li>
  <li>Design the front end</li>
  <li>Learn how to code vulnerable cod to SSRF</li>
  <li>Actually code it</li>
  <li>Test it.</li>
  <li>Think of more levels.</li>
</ul>

<p>Facing the first problem understanding the vulnerability and trying to design an application part where to practice. I went out to the internet watched some videos and kind of find a working solution and I did that proposal and it was accepted. I also did the SSRF section in the Portswigger web security academy in where you can find information about the vulnerability and it has a practical part, the labs part. </p>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/portswigger.png'}}" alt="how">
<p>From here I also got new ideas to work on the following levels for the application, that I will share with you just let me define how is going to work. In this PR I will try to do level one add the codebase and the first level. The first level consists of an image loader you can enter an URL and the server is going to send a request to load the image and show it in the front-end, the vulnerability comes into play when you call an internal resource using the file:/// protocol. </p>
<p>Things to do here, do the front-end and back-end code. Find the vulnerable code. Here I had to do a little bit of research but I managed to find an example of the implementation to the vulnerability I had to take lines and mix them with others, I had to do little adjustments. That's how I did the back-end and the front-end I just used the classical JS and HTML so that wasn't a big problem.</p>

<p>I tested the code and everything was working fine, so now it's time to do the PR. That's the next problem that I faced is to write a good proper PR so that the reviewers could understand what I was doing and the solution that I was proposing. This part of communication and I think personally that people want to read concrete and short things that contain just enough information I tried to that and also include some images about the new features.</p>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/PR.png'}}" alt="how">
<p>You can find more info about the project here: <a href="https://github.com/SasanLabs/VulnerableApp">VulnerableApp</a></p>
<p>Now... the results...</p>

<p>I got feedback from the PR and I think that it was good feedback, I mean I got some code corrections but in general, my work is good. I think I'm going to keep working on this project and I know that I can add more value and I add new levels and different vulnerabilities. The problem here is that I have to do some use-case research too... and that's the hard part, but... let's do it.</p>
<p>
I also want to mention that I really strived to do a good PR description and to make it easy for reviews to go through and my effort was rewarded.
</p>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/PRfeedback.png'}}" alt="how">
<p>Now things to do in the next week:</p>
<ul>
  <li>
Find all the use cases to know how the level designs are going to work
</li>
<li>Share that with the REPO maintainers </li>
<li>Fix some errors on my code</li>
<li>Code the new levels</li>
</ul>
<p>Let's get to it and see what happens this week.</p>
<br>
<p>Now, I'm going to share the questions and answers.</p>

<br>
<h2 id="how-java-annotations-add-or-inject-behavior-to-classes-or-methods">How Java annotations add or inject behavior to classes or methods?</h2>
<br>
<h2 id="what-is-the-problem">What is the problem?</h2>
<p>The main problem that I encountered is that when I first saw the application I saw that we had to create methods and only add annotations and I tough that by adding annotations we added some behavior to a method or class. Today I learned something new.</p>
<p>I want to show you how a method is declared and what it does:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">@AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.COMMAND_INJECTION,
            description = &quot;COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED&quot;)
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = &quot;COMMAND_INJECTION_URL_CONTAINING_IPADDRESS&quot;,
            htmlTemplate = &quot;LEVEL_1/CI_Level1&quot;,
            parameterName = IP_ADDRESS,
            sampleValues = {&quot;localhost&quot;})
    public ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;String&gt;&gt; getVulnerablePayloadLevel1(
            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {
        Supplier&lt;Boolean&gt; validator = () -&gt; StringUtils.isNotBlank(ipAddress);
        return new ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;String&gt;&gt;(
                new GenericVulnerabilityResponseBean&lt;String&gt;(
                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),
                        true),
                HttpStatus.OK);
    }</pre><pre class="hljs"><code>@AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.COMMAND_INJECTION,
            description = <span class="hljs-string">&quot;COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED&quot;</span>)
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = <span class="hljs-string">&quot;COMMAND_INJECTION_URL_CONTAINING_IPADDRESS&quot;</span>,
            htmlTemplate = <span class="hljs-string">&quot;LEVEL_1/CI_Level1&quot;</span>,
            parameterName = IP_ADDRESS,
            sampleValues = {<span class="hljs-string">&quot;localhost&quot;</span>})
    public ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;<span class="hljs-built_in">String</span>&gt;&gt; getVulnerablePayloadLevel1(
            @RequestParam(IP_ADDRESS) <span class="hljs-built_in">String</span> ipAddress) throws IOException {
        Supplier&lt;<span class="hljs-built_in">Boolean</span>&gt; validator = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> StringUtils.isNotBlank(ipAddress);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;<span class="hljs-built_in">String</span>&gt;&gt;(
                <span class="hljs-keyword">new</span> GenericVulnerabilityResponseBean&lt;<span class="hljs-built_in">String</span>&gt;(
                        <span class="hljs-built_in">this</span>.getResponseFromPingCommand(ipAddress, validator.get()).toString(),
                        <span class="hljs-literal">true</span>),
                HttpStatus.OK);
    }</code></pre></div>
<p>By looking at the VulnerableAppRequestMapping annotation I tough &quot;Well this is exposing the service and everything is working because of the annotation, the annotation is adding behavior to the method&quot;. Let's see if this is true that's why I have chosen this question.</p>
<h2 id="what-are-annotations">What Are Annotations?</h2>
<p>One word to explain annotation is metadata. <strong>Metadata is data about data.</strong> So annotations are metadata for code.</p>
<blockquote>
<p>Java annotations are used to provide meta data for your Java code. Being meta data, Java annotations do not directly affect the execution of your code, although some types of annotations can actually be used for that purpose.</p>
</blockquote>
<p>What I can understand from this is that we add these annotations that start with <code class="inline-code">@</code> to a class, method, or attribute, and by doing this we define data about that code that's under the annotation, by providing this kind of data by describing something we can't modify the logic flow of the code. Here is the important thing, by giving more data, logic won't change but now other Java apps may use that data to do something like using it in different situations.</p>
<p>We now know that the annotations are not doing something logical in the source code that we are working on let's now dissect the annotation.</p>
<h2 id="dissecting-the-vulnerableapprequestmapping-annotation">Dissecting the VulnerableAppRequestMapping annotation</h2>
<p>This is the code of the annotation:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">package org.sasanlabs.internal.utility.annotations;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.sasanlabs.internal.utility.Variant;
import org.springframework.core.annotation.AliasFor;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/** @author KSASAN preetkaran20@gmail.com */
@Retention(RetentionPolicy.RUNTIME)
@Target(value = ElementType.METHOD)
@RequestMapping
public @interface VulnerableAppRequestMapping {

    /**
     * Specify the level of the vulnerability. Url end point is exposed for each level.
     *
     * @return level
     */
    @AliasFor(annotation = RequestMapping.class)
    String value();

    /**
     * Specify whether the implementation can be considered secure, as in, non-exploitable.
     *
     * @return variant
     */
    Variant variant() default Variant.UNSECURE;

    /**
     * Describes the information about the input type, expected output and other factors. like say
     * input is needed as a URL or as a Cookie etc.
     *
     * @return Localization Key
     */
    String descriptionLabel() default &quot;EMPTY_LABEL&quot;;

    /**
     * Template name is used to construct the url for static resources like js/css/html. UI will
     * look for path to static templates like static/templates/JWTVulnerabilities/{htmlTemplate}.{js
     * or css or html} to construct final Html.
     *
     * @return template name
     */
    String htmlTemplate() default &quot;&quot;;

    /**
     * This information can be used by Scanners to know location in request where payload can be
     * injected. Default value is {@link RequestParameterLocation#QUERY_PARAM}
     *
     * @return location of parameter
     */
    RequestParameterLocation requestParameterLocation() default
            RequestParameterLocation.QUERY_PARAM;

    /**
     * This information can be used by Scanners to know the name of the key whose value is read by
     * the endpoint/vulnerability level for performing the operation.
     *
     * @return name of the parameter which holds the value
     */
    String parameterName() default &quot;&quot;;

    /**
     * This information is very useful for scanners in case of attacks which depends on the sample
     * values like JWT. In case of JWT there are two steps for the attack: 1. Fetch the token 2.
     * Fuzz and try
     *
     * &lt;p&gt;Sample values can be very helpful in removing the step 1.
     *
     * @return array of sample values.
     */
    String[] sampleValues() default {};

    /**
     * This information is not useful for now because we are for now only handling Get requests but
     * going further we might use this information and hence this is very useful for scanner.
     *
     * @return {@code RequestMethod} for the Level
     */
    @AliasFor(attribute = &quot;method&quot;, annotation = RequestMapping.class)
    RequestMethod requestMethod() default RequestMethod.GET;

    /**
     * ResponseType helps the implementer to know what is the type of response returned from the
     * rest/http api call. This is important for vulnerabilities which returns entire html or tags
     * like XSS vulnerability. The default responseType is {@link ResponseType#JSON}.
     *
     * @return ResonseType for the vulnerability level.
     */
    ResponseType responseType() default ResponseType.JSON;
}</pre><pre class="hljs"><code><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.sasanlabs</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.utility</span><span class="hljs-selector-class">.annotations</span>;

<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ElementType</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Retention</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.RetentionPolicy</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Target</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.sasanlabs</span><span class="hljs-selector-class">.internal</span><span class="hljs-selector-class">.utility</span><span class="hljs-selector-class">.Variant</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.AliasFor</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.RequestMapping</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.bind</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.RequestMethod</span>;

<span class="hljs-comment">/** @author KSASAN preetkaran20@gmail.com */</span>
<span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)
@Target(value = ElementType.METHOD)
@RequestMapping
public @interface VulnerableAppRequestMapping {

    <span class="hljs-comment">/**
     * Specify the level of the vulnerability. Url end point is exposed for each level.
     *
     * @return level
     */</span>
    <span class="hljs-keyword">@AliasFor</span>(annotation = RequestMapping.class)
    String value();

    <span class="hljs-comment">/**
     * Specify whether the implementation can be considered secure, as in, non-exploitable.
     *
     * @return variant
     */</span>
    <span class="hljs-selector-tag">Variant</span> <span class="hljs-selector-tag">variant</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">Variant</span><span class="hljs-selector-class">.UNSECURE</span>;

    <span class="hljs-comment">/**
     * Describes the information about the input type, expected output and other factors. like say
     * input is needed as a URL or as a Cookie etc.
     *
     * @return Localization Key
     */</span>
    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">descriptionLabel</span>() <span class="hljs-selector-tag">default</span> &quot;<span class="hljs-selector-tag">EMPTY_LABEL</span>&quot;;

    <span class="hljs-comment">/**
     * Template name is used to construct the url for static resources like js/css/html. UI will
     * look for path to static templates like static/templates/JWTVulnerabilities/{htmlTemplate}.{js
     * or css or html} to construct final Html.
     *
     * @return template name
     */</span>
    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">htmlTemplate</span>() <span class="hljs-selector-tag">default</span> &quot;&quot;;

    <span class="hljs-comment">/**
     * This information can be used by Scanners to know location in request where payload can be
     * injected. Default value is {@link RequestParameterLocation#QUERY_PARAM}
     *
     * @return location of parameter
     */</span>
    <span class="hljs-selector-tag">RequestParameterLocation</span> <span class="hljs-selector-tag">requestParameterLocation</span>() <span class="hljs-selector-tag">default</span>
            <span class="hljs-selector-tag">RequestParameterLocation</span><span class="hljs-selector-class">.QUERY_PARAM</span>;

    <span class="hljs-comment">/**
     * This information can be used by Scanners to know the name of the key whose value is read by
     * the endpoint/vulnerability level for performing the operation.
     *
     * @return name of the parameter which holds the value
     */</span>
    <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">parameterName</span>() <span class="hljs-selector-tag">default</span> &quot;&quot;;

    <span class="hljs-comment">/**
     * This information is very useful for scanners in case of attacks which depends on the sample
     * values like JWT. In case of JWT there are two steps for the attack: 1. Fetch the token 2.
     * Fuzz and try
     *
     * &lt;p&gt;Sample values can be very helpful in removing the step 1.
     *
     * @return array of sample values.
     */</span>
    <span class="hljs-selector-tag">String</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">sampleValues</span>() <span class="hljs-selector-tag">default</span> {};

    <span class="hljs-comment">/**
     * This information is not useful for now because we are for now only handling Get requests but
     * going further we might use this information and hence this is very useful for scanner.
     *
     * @return {@code RequestMethod} for the Level
     */</span>
    <span class="hljs-keyword">@AliasFor</span>(attribute = <span class="hljs-string">&quot;method&quot;</span>, annotation = RequestMapping.class)
    RequestMethod requestMethod() default RequestMethod.GET;

    <span class="hljs-comment">/**
     * ResponseType helps the implementer to know what is the type of response returned from the
     * rest/http api call. This is important for vulnerabilities which returns entire html or tags
     * like XSS vulnerability. The default responseType is {@link ResponseType#JSON}.
     *
     * @return ResonseType for the vulnerability level.
     */</span>
    <span class="hljs-selector-tag">ResponseType</span> <span class="hljs-selector-tag">responseType</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">ResponseType</span><span class="hljs-selector-class">.JSON</span>;
}</code></pre></div>
<p>Now we have to remember that annotations are only metadata so the attributes in the class are only for that. So here in this class, we have those attributes. We can see that there is not code for logical stuff or something that could modify the logical flow of the program. We can also see that is annotated with the @RequestMapping annotation that tells Spring to threaten this differently.</p>
<p>Now let's just see where is this annotation used.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">@AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.COMMAND_INJECTION,
            description = &quot;COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED&quot;)
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = &quot;COMMAND_INJECTION_URL_CONTAINING_IPADDRESS&quot;,
            htmlTemplate = &quot;LEVEL_1/CI_Level1&quot;,
            parameterName = IP_ADDRESS,
            sampleValues = {&quot;localhost&quot;})
    public ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;String&gt;&gt; getVulnerablePayloadLevel1(
            @RequestParam(IP_ADDRESS) String ipAddress) throws IOException {
        Supplier&lt;Boolean&gt; validator = () -&gt; StringUtils.isNotBlank(ipAddress);
        return new ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;String&gt;&gt;(
                new GenericVulnerabilityResponseBean&lt;String&gt;(
                        this.getResponseFromPingCommand(ipAddress, validator.get()).toString(),
                        true),
                HttpStatus.OK);
    }</pre><pre class="hljs"><code>@AttackVector(
            vulnerabilityExposed = VulnerabilitySubType.COMMAND_INJECTION,
            description = <span class="hljs-string">&quot;COMMAND_INJECTION_URL_PARAM_DIRECTLY_EXECUTED&quot;</span>)
    @VulnerableAppRequestMapping(
            value = LevelConstants.LEVEL_1,
            descriptionLabel = <span class="hljs-string">&quot;COMMAND_INJECTION_URL_CONTAINING_IPADDRESS&quot;</span>,
            htmlTemplate = <span class="hljs-string">&quot;LEVEL_1/CI_Level1&quot;</span>,
            parameterName = IP_ADDRESS,
            sampleValues = {<span class="hljs-string">&quot;localhost&quot;</span>})
    public ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;<span class="hljs-built_in">String</span>&gt;&gt; getVulnerablePayloadLevel1(
            @RequestParam(IP_ADDRESS) <span class="hljs-built_in">String</span> ipAddress) throws IOException {
        Supplier&lt;<span class="hljs-built_in">Boolean</span>&gt; validator = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> StringUtils.isNotBlank(ipAddress);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;GenericVulnerabilityResponseBean&lt;<span class="hljs-built_in">String</span>&gt;&gt;(
                <span class="hljs-keyword">new</span> GenericVulnerabilityResponseBean&lt;<span class="hljs-built_in">String</span>&gt;(
                        <span class="hljs-built_in">this</span>.getResponseFromPingCommand(ipAddress, validator.get()).toString(),
                        <span class="hljs-literal">true</span>),
                HttpStatus.OK);
    }</code></pre></div>
<p>We are going to find this annotation on the methods that are in the vulnerabilities classes and is putting data that describes that method and adding the request mapping annotation. Let's see the data in this method:</p>
<ul>
<li>value: Specifies the level of the vulnerability but also specifies the API route. Depending on this value the API endpoint is going to be here.</li>
<li>descriptionLabel: The message to show in the UI for the user, we can find these messages in a bundle.</li>
<li>htmlTemplate: The location of the HTML template</li>
<li>parameterName: The name of the parameters that could be useful for a scanner</li>
<li>samples: Useful for scanners.</li>
</ul>
<p>Now we have a clearer idea of what is happening and what's the annotation doing to our method. In another place of the code, we could see that metadata and try to get the method. Now let's try to find that place. We need to know this because the annotations in this project are the basis for everything.</p>
<p>We found this class:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">package org.sasanlabs.service.impl;

import com.fasterxml.jackson.core.JsonProcessingException;
import java.lang.reflect.Method;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import org.sasanlabs.beans.AllEndPointsResponseBean;
import org.sasanlabs.beans.AttackVectorResponseBean;
import org.sasanlabs.beans.LevelResponseBean;
import org.sasanlabs.beans.ScannerResponseBean;
import org.sasanlabs.configuration.VulnerableAppProperties;
import org.sasanlabs.internal.utility.EnvUtils;
import org.sasanlabs.internal.utility.FrameworkConstants;
import org.sasanlabs.internal.utility.GenericUtils;
import org.sasanlabs.internal.utility.MessageBundle;
import org.sasanlabs.internal.utility.annotations.AttackVector;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
import org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
import org.sasanlabs.service.IEndPointsInformationProvider;
import org.sasanlabs.vulnerability.types.VulnerabilityType;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

/** @author KSASAN preetkaran20@gmail.com */
@Service
public class EndPointsInformationProvider implements IEndPointsInformationProvider {

    private EnvUtils envUtils;

    private MessageBundle messageBundle;

    private VulnerableAppProperties vulnerableAppProperties;

    int port;

    public EndPointsInformationProvider(
            EnvUtils envUtils,
            MessageBundle messageBundle,
            VulnerableAppProperties vulnerableAppProperties,
            @Value(&quot;${server.port}&quot;) int port) {
        this.envUtils = envUtils;
        this.messageBundle = messageBundle;
        this.vulnerableAppProperties = vulnerableAppProperties;
        this.port = port;
    }

    @Override
    public List&lt;AllEndPointsResponseBean&gt; getSupportedEndPoints() throws JsonProcessingException {
        List&lt;AllEndPointsResponseBean&gt; allEndpoints = new ArrayList&lt;&gt;();
        Map&lt;String, Object&gt; nameVsCustomVulnerableEndPoint =
                envUtils.getAllClassesAnnotatedWithVulnerableAppRestController();
        for (Map.Entry&lt;String, Object&gt; entry : nameVsCustomVulnerableEndPoint.entrySet()) {
            String name = entry.getKey();
            Class&lt;?&gt; clazz = entry.getValue().getClass();
            if (clazz.isAnnotationPresent(VulnerableAppRestController.class)) {
                VulnerableAppRestController vulnerableServiceRestEndPoint =
                        clazz.getAnnotation(VulnerableAppRestController.class);
                String description = vulnerableServiceRestEndPoint.descriptionLabel();
                VulnerabilityType[] vulnerabilityTypes = vulnerableServiceRestEndPoint.type();
                AllEndPointsResponseBean allEndPointsResponseBean = new AllEndPointsResponseBean();
                allEndPointsResponseBean.setName(name);
                allEndPointsResponseBean.setDescription(messageBundle.getString(description, null));
                allEndPointsResponseBean.setVulnerabilityTypes(vulnerabilityTypes);

                Method[] methods = clazz.getDeclaredMethods();
                for (Method method : methods) {
                    VulnerableAppRequestMapping vulnLevel =
                            method.getAnnotation(VulnerableAppRequestMapping.class);
                    if (vulnLevel != null) {
                        AttackVector[] attackVectors =
                                method.getAnnotationsByType(AttackVector.class);
                        LevelResponseBean levelResponseBean = new LevelResponseBean();
                        levelResponseBean.setLevel(vulnLevel.value());
                        levelResponseBean.setVariant(vulnLevel.variant());
                        levelResponseBean.setDescription(
                                messageBundle.getString(vulnLevel.descriptionLabel(), null));
                        levelResponseBean.setHtmlTemplate(vulnLevel.htmlTemplate());

                        levelResponseBean.setRequestParameterLocation(
                                vulnLevel.requestParameterLocation());
                        levelResponseBean.setParameterName(vulnLevel.parameterName());
                        levelResponseBean.setSampleValues(vulnLevel.sampleValues());
                        levelResponseBean.setRequestMethod(vulnLevel.requestMethod());
                        for (AttackVector attackVector : attackVectors) {
                            levelResponseBean
                                    .getAttackVectorResponseBeans()
                                    .add(
                                            new AttackVectorResponseBean(
                                                    new ArrayList&lt;&gt;(
                                                            Arrays.asList(
                                                                    attackVector
                                                                            .vulnerabilityExposed())),
                                                    vulnerableAppProperties.getAttackVectorProperty(
                                                            attackVector.payload()),
                                                    messageBundle.getString(
                                                            attackVector.description(), null)));
                        }
                        allEndPointsResponseBean.getLevelDescriptionSet().add(levelResponseBean);
                    }
                }
                allEndpoints.add(allEndPointsResponseBean);
            }
        }
        return allEndpoints;
    }

    @Override
    public List&lt;ScannerResponseBean&gt; getScannerRelatedEndPointInformation()
            throws JsonProcessingException, UnknownHostException {
        List&lt;AllEndPointsResponseBean&gt; allEndPointsResponseBeans = this.getSupportedEndPoints();
        List&lt;ScannerResponseBean&gt; scannerResponseBeans = new ArrayList&lt;&gt;();
        for (AllEndPointsResponseBean allEndPointsResponseBean : allEndPointsResponseBeans) {
            for (LevelResponseBean levelResponseBean :
                    allEndPointsResponseBean.getLevelDescriptionSet()) {
                for (AttackVectorResponseBean attackVectorResponseBean :
                        levelResponseBean.getAttackVectorResponseBeans()) {
                    scannerResponseBeans.add(
                            new ScannerResponseBean(
                                    new StringBuilder()
                                            .append(FrameworkConstants.HTTP)
                                            .append(GenericUtils.LOCALHOST)
                                            .append(FrameworkConstants.COLON)
                                            .append(port)
                                            .append(FrameworkConstants.SLASH)
                                            .append(allEndPointsResponseBean.getName())
                                            .append(FrameworkConstants.SLASH)
                                            .append(levelResponseBean.getLevel())
                                            .toString(),
                                    levelResponseBean.getLevel(),
                                    levelResponseBean.getVariant().toString(),
                                    levelResponseBean.getRequestParameterLocation(),
                                    levelResponseBean.getParameterName(),
                                    levelResponseBean.getSampleValues(),
                                    levelResponseBean.getRequestMethod(),
                                    attackVectorResponseBean.getVulnerabilityTypes()));
                }
            }
        }
        return scannerResponseBeans;
    }
}</pre><pre class="hljs"><code>package org.sasanlabs.service.impl;

<span class="hljs-keyword">import</span> com.fasterxml.jackson.core.JsonProcessingException;
<span class="hljs-keyword">import</span> java.lang.reflect.<span class="hljs-keyword">Method</span>;
<span class="hljs-keyword">import</span> java.net.UnknownHostException;
<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Arrays;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> org.sasanlabs.beans.AllEndPointsResponseBean;
<span class="hljs-keyword">import</span> org.sasanlabs.beans.AttackVectorResponseBean;
<span class="hljs-keyword">import</span> org.sasanlabs.beans.LevelResponseBean;
<span class="hljs-keyword">import</span> org.sasanlabs.beans.ScannerResponseBean;
<span class="hljs-keyword">import</span> org.sasanlabs.<span class="hljs-keyword">configuration</span>.VulnerableAppProperties;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.EnvUtils;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.FrameworkConstants;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.GenericUtils;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.MessageBundle;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.annotations.AttackVector;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.annotations.VulnerableAppRequestMapping;
<span class="hljs-keyword">import</span> org.sasanlabs.internal.utility.annotations.VulnerableAppRestController;
<span class="hljs-keyword">import</span> org.sasanlabs.service.IEndPointsInformationProvider;
<span class="hljs-keyword">import</span> org.sasanlabs.vulnerability.<span class="hljs-keyword">types</span>.VulnerabilityType;
<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.<span class="hljs-keyword">Value</span>;
<span class="hljs-keyword">import</span> org.springframework.stereotype.Service;

<span class="hljs-comment">/** @author KSASAN preetkaran20@gmail.com */</span>
@Service
<span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> EndPointsInformationProvider implements IEndPointsInformationProvider {

    private EnvUtils envUtils;

    private MessageBundle messageBundle;

    private VulnerableAppProperties vulnerableAppProperties;

    <span class="hljs-type">int</span> port;

    <span class="hljs-built_in">public</span> EndPointsInformationProvider(
            EnvUtils envUtils,
            MessageBundle messageBundle,
            VulnerableAppProperties vulnerableAppProperties,
            @<span class="hljs-keyword">Value</span>(&quot;${server.port}&quot;) <span class="hljs-type">int</span> port) {
        this.envUtils = envUtils;
        this.messageBundle = messageBundle;
        this.vulnerableAppProperties = vulnerableAppProperties;
        this.port = port;
    }

    @Override
    <span class="hljs-built_in">public</span> List&lt;AllEndPointsResponseBean&gt; getSupportedEndPoints() throws JsonProcessingException {
        List&lt;AllEndPointsResponseBean&gt; allEndpoints = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();
        Map&lt;String, <span class="hljs-keyword">Object</span>&gt; nameVsCustomVulnerableEndPoint =
                envUtils.getAllClassesAnnotatedWithVulnerableAppRestController();
        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, <span class="hljs-keyword">Object</span>&gt; entry : nameVsCustomVulnerableEndPoint.entrySet()) {
            String <span class="hljs-type">name</span> = entry.getKey();
            <span class="hljs-keyword">Class</span>&lt;?&gt; clazz = entry.getValue().getClass();
            <span class="hljs-keyword">if</span> (clazz.isAnnotationPresent(VulnerableAppRestController.<span class="hljs-keyword">class</span>)) {
                VulnerableAppRestController vulnerableServiceRestEndPoint =
                        clazz.getAnnotation(VulnerableAppRestController.<span class="hljs-keyword">class</span>);
                String description = vulnerableServiceRestEndPoint.descriptionLabel();
                VulnerabilityType[] vulnerabilityTypes = vulnerableServiceRestEndPoint.<span class="hljs-keyword">type</span>();
                AllEndPointsResponseBean allEndPointsResponseBean = <span class="hljs-built_in">new</span> AllEndPointsResponseBean();
                allEndPointsResponseBean.setName(<span class="hljs-type">name</span>);
                allEndPointsResponseBean.setDescription(messageBundle.getString(description, <span class="hljs-keyword">null</span>));
                allEndPointsResponseBean.setVulnerabilityTypes(vulnerabilityTypes);

                <span class="hljs-keyword">Method</span>[] methods = clazz.getDeclaredMethods();
                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">Method</span> <span class="hljs-keyword">method</span> : methods) {
                    VulnerableAppRequestMapping vulnLevel =
                            <span class="hljs-keyword">method</span>.getAnnotation(VulnerableAppRequestMapping.<span class="hljs-keyword">class</span>);
                    <span class="hljs-keyword">if</span> (vulnLevel != <span class="hljs-keyword">null</span>) {
                        AttackVector[] attackVectors =
                                <span class="hljs-keyword">method</span>.getAnnotationsByType(AttackVector.<span class="hljs-keyword">class</span>);
                        LevelResponseBean levelResponseBean = <span class="hljs-built_in">new</span> LevelResponseBean();
                        levelResponseBean.setLevel(vulnLevel.<span class="hljs-keyword">value</span>());
                        levelResponseBean.setVariant(vulnLevel.variant());
                        levelResponseBean.setDescription(
                                messageBundle.getString(vulnLevel.descriptionLabel(), <span class="hljs-keyword">null</span>));
                        levelResponseBean.setHtmlTemplate(vulnLevel.htmlTemplate());

                        levelResponseBean.setRequestParameterLocation(
                                vulnLevel.requestParameterLocation());
                        levelResponseBean.setParameterName(vulnLevel.parameterName());
                        levelResponseBean.setSampleValues(vulnLevel.sampleValues());
                        levelResponseBean.setRequestMethod(vulnLevel.requestMethod());
                        <span class="hljs-keyword">for</span> (AttackVector attackVector : attackVectors) {
                            levelResponseBean
                                    .getAttackVectorResponseBeans()
                                    .<span class="hljs-keyword">add</span>(
                                            <span class="hljs-built_in">new</span> AttackVectorResponseBean(
                                                    <span class="hljs-built_in">new</span> ArrayList&lt;&gt;(
                                                            Arrays.asList(
                                                                    attackVector
                                                                            .vulnerabilityExposed())),
                                                    vulnerableAppProperties.getAttackVectorProperty(
                                                            attackVector.payload()),
                                                    messageBundle.getString(
                                                            attackVector.description(), <span class="hljs-keyword">null</span>)));
                        }
                        allEndPointsResponseBean.getLevelDescriptionSet().<span class="hljs-keyword">add</span>(levelResponseBean);
                    }
                }
                allEndpoints.<span class="hljs-keyword">add</span>(allEndPointsResponseBean);
            }
        }
        <span class="hljs-keyword">return</span> allEndpoints;
    }

    @Override
    <span class="hljs-built_in">public</span> List&lt;ScannerResponseBean&gt; getScannerRelatedEndPointInformation()
            throws JsonProcessingException, UnknownHostException {
        List&lt;AllEndPointsResponseBean&gt; allEndPointsResponseBeans = this.getSupportedEndPoints();
        List&lt;ScannerResponseBean&gt; scannerResponseBeans = <span class="hljs-built_in">new</span> ArrayList&lt;&gt;();
        <span class="hljs-keyword">for</span> (AllEndPointsResponseBean allEndPointsResponseBean : allEndPointsResponseBeans) {
            <span class="hljs-keyword">for</span> (LevelResponseBean levelResponseBean :
                    allEndPointsResponseBean.getLevelDescriptionSet()) {
                <span class="hljs-keyword">for</span> (AttackVectorResponseBean attackVectorResponseBean :
                        levelResponseBean.getAttackVectorResponseBeans()) {
                    scannerResponseBeans.<span class="hljs-keyword">add</span>(
                            <span class="hljs-built_in">new</span> ScannerResponseBean(
                                    <span class="hljs-built_in">new</span> StringBuilder()
                                            .append(FrameworkConstants.HTTP)
                                            .append(GenericUtils.LOCALHOST)
                                            .append(FrameworkConstants.COLON)
                                            .append(port)
                                            .append(FrameworkConstants.SLASH)
                                            .append(allEndPointsResponseBean.getName())
                                            .append(FrameworkConstants.SLASH)
                                            .append(levelResponseBean.getLevel())
                                            .toString(),
                                    levelResponseBean.getLevel(),
                                    levelResponseBean.getVariant().toString(),
                                    levelResponseBean.getRequestParameterLocation(),
                                    levelResponseBean.getParameterName(),
                                    levelResponseBean.getSampleValues(),
                                    levelResponseBean.getRequestMethod(),
                                    attackVectorResponseBean.getVulnerabilityTypes()));
                }
            }
        }
        <span class="hljs-keyword">return</span> scannerResponseBeans;
    }
}</code></pre></div>
<p>In this class, we can find the getSupportedEndPoints method. Let's try to go line by line and see what's happening</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">Map&lt;String, Object&gt; nameVsCustomVulnerableEndPoint =
        envUtils.getAllClassesAnnotatedWithVulnerableAppRestController();</pre><pre class="hljs"><code><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; nameVsCustomVulnerableEndPoint =
        envUtils.getAllClassesAnnotatedWithVulnerableAppRestController();</code></pre></div>
<p>In this line is getting all the methods annotated with the VulnerableAppRestController annotation</p>
<p>We can do it with this</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">return context.getBeansWithAnnotation(VulnerableAppRestController.class);</pre><pre class="hljs"><code><span class="hljs-keyword">return</span> context.getBeansWithAnnotation(VulnerableAppRestController.<span class="hljs-keyword">class</span>);</code></pre></div>
<p>Then iterates over these methods, and is now USING THE METADA from the annotations:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">String description = vulnerableServiceRestEndPoint.descriptionLabel();
VulnerabilityType[] vulnerabilityTypes = vulnerableServiceRestEndPoint.type();
AllEndPointsResponseBean allEndPointsResponseBean = new AllEndPointsResponseBean();
allEndPointsResponseBean.setName(name);
allEndPointsResponseBean.setDescription(messageBundle.getString(description, null));
allEndPointsResponseBean.setVulnerabilityTypes(vulnerabilityTypes);</pre><pre class="hljs"><code>String description = vulnerableServiceRestEndPoint.description<span class="hljs-constructor">Label()</span>;
VulnerabilityType<span class="hljs-literal">[]</span> vulnerabilityTypes = vulnerableServiceRestEndPoint.<span class="hljs-keyword">type</span><span class="hljs-literal">()</span>;
AllEndPointsResponseBean allEndPointsResponseBean = <span class="hljs-keyword">new</span> <span class="hljs-constructor">AllEndPointsResponseBean()</span>;
allEndPointsResponseBean.set<span class="hljs-constructor">Name(<span class="hljs-params">name</span>)</span>;
allEndPointsResponseBean.set<span class="hljs-constructor">Description(<span class="hljs-params">messageBundle</span>.<span class="hljs-params">getString</span>(<span class="hljs-params">description</span>, <span class="hljs-params">null</span>)</span>);
allEndPointsResponseBean.set<span class="hljs-constructor">VulnerabilityTypes(<span class="hljs-params">vulnerabilityTypes</span>)</span>;</code></pre></div>
<p>And also is getting other information from other annotation declarations and it's creating a list of objects and return it.</p>
<p>In conclusion, in this project, we can see that annotations don't do something logical but a method annotated has data, extra data that we can define in a new annotation. With this, we can identify methods and their information, and now we can add some logical code to perform what we want with these methods.</p>

<br>





<p>This one of the questions that I have to answer so let's try to go step by step to finally get an answer, so first step is to learn what is Selenium and TestNG because there are commonly used together.</p>
<h2 id="selenium">Selenium</h2>
<blockquote>
<p>Selenium is an umbrella project encapsulating a variety of tools and libraries enabling web browser automation.</p>
</blockquote>
<ul>
<li>Selenium specifically provides an infrastructure for the W3C WebDriver specification — a platform and language-neutral coding interface compatible with all major web browsers.</li>
<li>Selenium is a free (open-source) automated testing framework used to validate web applications across different browsers and platforms.</li>
<li>You can use multiple programming languages like Java, C#, Python etc to create Selenium Test Scripts.</li>
</ul>
<p>Basically, what I can understand, it's a test framework in which you create code that executes a browser and actions on that browser to accomplish something in the Front-end.</p>
<h2 id="testng">TestNG</h2>
<blockquote>
<p>TestNG is a testing framework inspired from JUnit and NUnit but introducing some new functionalities that make it more powerful and easier to use.</p>
</blockquote>
<p><img class="center-img" src="{{ '/assets/encora/weekly/week10/testng.png'}}" alt="Captura de Pantalla 2021-06-14 a la(s) 18.14.18.png"></p>
<ul>
<li>TestNG is designed to cover all categories of tests:  unit, functional, end-to-end, integration, etc...</li>
<li>TestNG provides you full control over the test cases and the execution of the test cases. Due to this reason, TestNG is also known as a testing framework.</li>
<li>It is an open source automated TestNG framework. In TestNG, NG stands for &quot;Next Generation&quot;.</li>
<li>TestNG framework eliminates the limitations of the older framework by providing more powerful and flexible test cases with help of easy annotations, grouping, sequencing and parametrizing.</li>
</ul>
<p>Now we can of understand whate they are but let's try to understand why they work together.</p>
<h2 id="why-use-testng-with-selenium">Why Use TestNG with Selenium?</h2>
<ul>
<li>Default Selenium tests do not generate a proper format for the test results. Using TestNG in Selenium, we can generate test results.</li>
<li>Generate the report in a proper format including a number of test cases runs, the number of test cases passed, the number of test cases failed, and the number of test cases skipped.</li>
<li>Multiple test cases can be grouped more easily by converting them into testng.xml file. In which you can make priorities which test case should be executed first.</li>
<li>Using testng, you can execute multiple test cases on multiple browsers, i.e., cross browser testing.</li>
<li>Annotations used in the testing are very easy to understand ex: @BeforeMethod, @AfterMethod, @BeforeTest, @AfterTest</li>
</ul>
<p>The reasons that I can understand why these are used together are:</p>
<ul>
<li>Sometimes you have to make assertions and you need a framework to do this you can use JUnit but people prefer TestNG.</li>
<li>Since Selenium does not have any built-in hardware for generating test reports you have to use TestNG.</li>
<li>TestNG has a lot of functionalities to manage the tests and using it with Selenium you can do integration tests.</li>
<li>TestNG is a testing framework that is capable of making - Selenium tests easier to understand and of generating reports that are easy to understand.</li>
<li>Test cases can be grouped more easily.</li>
<li>A test case can be executed at different times using the keyword invocationCount by assigning an iteration number to invocationCount variable</li>
</ul>
<h2 id="annotations">Annotations</h2>
<p>I seems that <code class="inline-code">@Factory</code> and <code class="inline-code">@DataProvider</code> are Java annotations, let's try to find the source code for this two annotations.</p>
<p><img class="center-img" src="{{ '/assets/encora/weekly/week10/classes.png'}}" alt="Captura de Pantalla 2021-06-14 a la(s) 18.51.57.png"></p>
<p>It seems that we can find the source code here.</p>
<p>Here we have the factory</p>
<p><img class="center-img" src="{{ '/assets/encora/weekly/week10/factory.png'}}" alt="Captura de Pantalla 2021-06-14 a la(s) 18.52.27.png"></p>
<p>And the DataProvider also is here</p>
<p><img class="center-img" src="{{ '/assets/encora/weekly/week10/provider.png'}}"alt="Captura de Pantalla 2021-06-14 a la(s) 18.53.11.png"></p>
<h2 id="data-provider">Data Provider</h2>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">package org.testng.annotations;

import static java.lang.annotation.ElementType.METHOD;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 * Mark a method as supplying data for a test method.
 *
 * &lt;p&gt;The {@link #name() name} defaults to the name of the annotated method.
 *
 * &lt;p&gt;The annotated method must return any of the following:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code Object[][]} or {@code Iterator&lt;Object[]&gt;}, where each {@code Object[]} is assigned
 *       to the parameter list of the test method.
 *   &lt;li&gt;{@code Object[]} or {@code Iterator&lt;Object&gt;}, where each {@code Object} is assigned to the
 *       single parameter of the test method.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The {@link Test @Test} method that wants to receive data from this {@link DataProvider} needs
 * to use a {@link Test#dataProvider()} name equal to the name of this annotation.
 */
@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
@Target({METHOD})
@Documented
public @interface DataProvider {

  /**
   * The name of this DataProvider.
   *
   * @return the value (default empty)
   */
  String name() default &quot;&quot;;

  /**
   * Whether this data provider should be run in parallel.
   *
   * @return the value (default false)
   */
  boolean parallel() default false;

  /**
   * Which indices to run from this data provider, default: all.
   *
   * @return the value
   */
  int[] indices() default {};
}</pre><pre class="hljs"><code><span class="hljs-keyword">package</span> org.testng.annotations;

<span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.annotation.ElementType.METHOD;

<span class="hljs-keyword">import</span> java.lang.annotation.Documented;
<span class="hljs-keyword">import</span> java.lang.annotation.Retention;
<span class="hljs-keyword">import</span> java.lang.annotation.Target;

<span class="hljs-comment">/**
 * Mark a method as supplying data for a test method.
 *
 * &lt;p&gt;The {<span class="hljs-doctag">@link</span> #name() name} defaults to the name of the annotated method.
 *
 * &lt;p&gt;The annotated method must return any of the following:
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{<span class="hljs-doctag">@code</span> Object[][]} or {<span class="hljs-doctag">@code</span> Iterator&lt;Object[]&gt;}, where each {<span class="hljs-doctag">@code</span> Object[]} is assigned
 *       to the parameter list of the test method.
 *   &lt;li&gt;{<span class="hljs-doctag">@code</span> Object[]} or {<span class="hljs-doctag">@code</span> Iterator&lt;Object&gt;}, where each {<span class="hljs-doctag">@code</span> Object} is assigned to the
 *       single parameter of the test method.
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The {<span class="hljs-doctag">@link</span> Test <span class="hljs-doctag">@Test</span>} method that wants to receive data from this {<span class="hljs-doctag">@link</span> DataProvider} needs
 * to use a {<span class="hljs-doctag">@link</span> Test#dataProvider()} name equal to the name of this annotation.
 */</span>
<span class="hljs-meta">@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)</span>
<span class="hljs-meta">@Target({METHOD})</span>
<span class="hljs-meta">@Documented</span>
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DataProvider {

  <span class="hljs-comment">/**
   * The name of this DataProvider.
   *
   * <span class="hljs-doctag">@return</span> the value (default empty)
   */</span>
  <span class="hljs-function">String <span class="hljs-title">name</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;

  <span class="hljs-comment">/**
   * Whether this data provider should be run in parallel.
   *
   * <span class="hljs-doctag">@return</span> the value (default false)
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">parallel</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;

  <span class="hljs-comment">/**
   * Which indices to run from this data provider, default: all.
   *
   * <span class="hljs-doctag">@return</span> the value
   */</span>
  <span class="hljs-keyword">int</span>[] indices() <span class="hljs-keyword">default</span> {};
}</code></pre></div>
<p>This is an annotation then, is to mark a method to be treated differently, we can mark a method using the <code class="inline-code">@DataProvider</code>  annotation on top of the method. According to the code, this is going to mark a method as the data supplier for a test method. Maybe the method is where you load a file or database.</p>
<p>The first attribute is called name which is the name assigned to the data provider method. It has another attribute called parallel which indicates if the data provider should be run in parallel. The last attribute is the indices which indicate which indices should be executed from the data provider.</p>
<p>In conclusion, this is going to make Java threat a method annotated with Data Provider as the source for data for a test and we can do invoke this method by the given name. And is going to run the number of times given in the indices attribute or the number of objects in the return object.</p>
<p>Example:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">import org.testng.annotations.DataProvider;
import org.testng.annotations.Optional;
import org.testng.annotations.Parameters;
import org.testng.annotations.Test;

public class DP
{
 @DataProvider (name = &quot;data-provider&quot;)
 public Object[][] dpMethod(){
 return new Object[][]
 }

    @Test (dataProvider = &quot;data-provider&quot;)
    public void myTest (String val) {
        System.out.println(&quot;Passed Parameter Is : &quot; + val);
    }
}</pre><pre class="hljs"><code><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.testng.annotations.DataProvider;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.testng.annotations.Optional;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.testng.annotations.Parameters;</span>
<span class="hljs-meta"><span class="hljs-meta-keyword">import</span> org.testng.annotations.Test;</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DP</span>
</span>{
 @DataProvider (name = <span class="hljs-string">&quot;data-provider&quot;</span>)
 <span class="hljs-keyword">public</span> Object[][] dpMethod(){
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Object[][], {<span class="hljs-string">&quot;Second-Value&quot;</span>}};
 }

    @Test (dataProvider = <span class="hljs-string">&quot;data-provider&quot;</span>)
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> myTest (String val) {
        System.out.println(<span class="hljs-string">&quot;Passed Parameter Is : &quot;</span> + val);
    }
}</code></pre></div>
<p>Due to the indices in this case the test is going to run 2 times.</p>
<h2 id="factory">Factory</h2>
<p>Now let's see the factory code.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">package org.testng.annotations;

import java.lang.annotation.Documented;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

/**
 * Marks a method as a factory that returns objects that will be used by TestNG as Test classes. The
 * method must return Object[].
 */
@Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
@Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.CONSTRUCTOR})
@Documented
public @interface Factory {
  /**
   * The name of the data provider for this test method.
   *
   * @return the data provider name (default none)
   * @see org.testng.annotations.DataProvider
   */
  String dataProvider() default &quot;&quot;;

  /**
   * The class where to look for the data provider. If not specified, the dataprovider will be
   * looked on the class of the current test method or one of its super classes. If this attribute
   * is specified, the data provider method needs to be static on the specified class.
   *
   * @return the data provider class (default none)
   */
  Class&lt;?&gt; dataProviderClass() default Object.class;

  /**
   * Whether this factory is enabled.
   *
   * @return the value (default true)
   */
  boolean enabled() default true;

  int[] indices() default {};
}</pre><pre class="hljs"><code><span class="hljs-selector-tag">package</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.testng</span><span class="hljs-selector-class">.annotations</span>;

<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Documented</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Retention</span>;
<span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.Target</span>;

<span class="hljs-comment">/**
 * Marks a method as a factory that returns objects that will be used by TestNG as Test classes. The
 * method must return Object[].
 */</span>
<span class="hljs-keyword">@Retention</span>(java.lang.annotation.RetentionPolicy.RUNTIME)
@Target({<span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ElementType</span><span class="hljs-selector-class">.METHOD</span>, <span class="hljs-selector-tag">java</span><span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ElementType</span><span class="hljs-selector-class">.CONSTRUCTOR</span>})
<span class="hljs-keyword">@Documented</span>
public @interface Factory {
  <span class="hljs-comment">/**
   * The name of the data provider for this test method.
   *
   * @return the data provider name (default none)
   * @see org.testng.annotations.DataProvider
   */</span>
  <span class="hljs-selector-tag">String</span> <span class="hljs-selector-tag">dataProvider</span>() <span class="hljs-selector-tag">default</span> &quot;&quot;;

  <span class="hljs-comment">/**
   * The class where to look for the data provider. If not specified, the dataprovider will be
   * looked on the class of the current test method or one of its super classes. If this attribute
   * is specified, the data provider method needs to be static on the specified class.
   *
   * @return the data provider class (default none)
   */</span>
  <span class="hljs-selector-tag">Class</span>&lt;?&gt; <span class="hljs-selector-tag">dataProviderClass</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.class</span>;

  <span class="hljs-comment">/**
   * Whether this factory is enabled.
   *
   * @return the value (default true)
   */</span>
  <span class="hljs-selector-tag">boolean</span> <span class="hljs-selector-tag">enabled</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-selector-tag">true</span>;

  <span class="hljs-selector-tag">int</span><span class="hljs-selector-attr">[]</span> <span class="hljs-selector-tag">indices</span>() <span class="hljs-selector-tag">default</span> {};
}</code></pre></div>
<p>The first thing to note here is the main description of the annotation. Marks a method as a factory, but the thing to note here is that provides objects, but not. simple objects for testing, it is important to note that, instead it provides objects to be used by TestNG for test classes. We are not returning data for testing nor simple objects, instead, we are going to return objects for testing in simple words, the tests</p>
<p>The attributes of the class, once again a name to identify it. A data provider class where to get the data. Enabled a boolean whether this factory is enabled. Finally the indices once again.</p>
<p>Finally, it has to be used on a method that returns Object[]. Is that, the method has to return test objects, marked with the <code class="inline-code">@Test</code> annotation, we have to save in the Object[] array the tests and the <code class="inline-code">@Factory</code> is going to cover that method into a factory. Why would we use this when you want to run multiple test classes through a single test class.</p>
<p>Example:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">package com.journaldev.utils;

import org.testng.annotations.Test;

public class Test1 {

    @Test
    public void test1() {
        System.out.println(&quot;Test1 test method&quot;);
    }
}



package com.journaldev.utils;

import org.testng.annotations.Test;

public class Test2 {

    @Test
    public void test2() {
        System.out.println(&quot;Test2 test method&quot;);
    }
}

package com.journaldev.utils;

import org.testng.annotations.Factory;

public class TestNGFactory {

    @Factory()
    public Object[] getTestClasses() {
        Object[] tests = new Object[2];
        tests[0] = new Test1();
        tests[1] = new Test2();
        return tests;
    }

}</pre><pre class="hljs"><code><span class="hljs-keyword">package</span> com.journaldev.utils;

<span class="hljs-keyword">import</span> org.testng.annotations.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test1</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">&quot;Test1 test method&quot;</span>);
    }
}



<span class="hljs-keyword">package</span> com.journaldev.utils;

<span class="hljs-keyword">import</span> org.testng.annotations.Test;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test2</span> </span>{

    <span class="hljs-meta">@Test</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>{
        System.out.println(<span class="hljs-string">&quot;Test2 test method&quot;</span>);
    }
}

<span class="hljs-keyword">package</span> com.journaldev.utils;

<span class="hljs-keyword">import</span> org.testng.annotations.Factory;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestNGFactory</span> </span>{

    <span class="hljs-meta">@Factory()</span>
    <span class="hljs-keyword">public</span> Object[] getTestClasses() {
        Object[] tests = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">2</span>];
        tests[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> Test1();
        tests[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Test2();
        <span class="hljs-keyword">return</span> tests;
    }

}</code></pre></div>
<p><strong>Output</strong></p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">[RemoteTestNG] detected TestNG version 6.14.3
Test1 test method
Test2 test method
PASSED: test1
PASSED: test2

===============================================
    Default test
    Tests run: 2, Failures: 0, Skips: 0
===============================================


===============================================
Default suite
Total tests run: 2, Failures: 0, Skips: 0
===============================================</pre><pre class="hljs"><code>[RemoteTestNG] detected TestNG version 6.14.3
Test1 test method
Test2 test method
PASSED: test1
PASSED: test2

===============================================
    Default test
    Tests run: 2, Failures: 0, Skips: 0
===============================================


===============================================
Default suite
Total tests run: 2, Failures: 0, Skips: 0
===============================================</code></pre></div>



<br>
<h2>How multiprocessing package manages streams when calling stdout and stderr and how could I do to not split streams when starting a process.</h2>
<br>
<p>We need to know how streams work because one of the PRs that I'm working on is having a problem with the output and needs a special solution for that. Once again I know nothing so let's try to go step by step. First of all, let's see what is the process class, stdout, and stderr.</p>
<h2 id="process-class">Process class</h2>
<blockquote>
<p>In multiprocessing, processes are spawned by creating a Process object and then calling its start() method.</p>
</blockquote>
<p>Process follows the API of threading.Thread. A trivial example of a multiprocess program is</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">from multiprocessing import Process

def f(name):
    print('hello', name)

if __name__ == '__main__':
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()</pre><pre class="hljs"><code><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process

def f(<span class="hljs-type">name</span>):
    print(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-type">name</span>)

<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:
    p = Process(target=f, args=(<span class="hljs-string">&#x27;bob&#x27;</span>,))
    p.<span class="hljs-keyword">start</span>()
    p.<span class="hljs-keyword">join</span>()</code></pre></div>
<p>Process objects represent activity that is run in a separate process. The Process class has equivalents of all the methods of threading.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">class multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</pre><pre class="hljs"><code>class multiprocessing.Process(<span class="hljs-attribute">group</span>=None, <span class="hljs-attribute">target</span>=None, <span class="hljs-attribute">name</span>=None, args=(), kwargs={}, *, <span class="hljs-attribute">daemon</span>=None)</code></pre></div>
<ul>
<li>Target: is the callable object to be invoked by the run() method.</li>
<li>Args: is the argument tuple for the target invocation.</li>
</ul>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```"> &gt;&gt;&gt; import multiprocessing, time, signal
 &gt;&gt;&gt; p = multiprocessing.Process(target=time.sleep, args=(1000,))
 &gt;&gt;&gt; print(p, p.is_alive())
 &lt;Process ... initial&gt; False
 &gt;&gt;&gt; p.start()
 &gt;&gt;&gt; print(p, p.is_alive())
 &lt;Process ... started&gt; True
 &gt;&gt;&gt; p.terminate()
 &gt;&gt;&gt; time.sleep(0.1)
 &gt;&gt;&gt; print(p, p.is_alive())
 &lt;Process ... stopped exitcode=-SIGTERM&gt; False
 &gt;&gt;&gt; p.exitcode == -signal.SIGTERM
 True</pre><pre class="hljs"><code> &gt;&gt;&gt; import multiprocessing, time, signal
 &gt;&gt;&gt; p = multiprocessing.Process(<span class="hljs-attribute">target</span>=time.sleep, args=(1000,))
 &gt;&gt;&gt; <span class="hljs-builtin-name">print</span>(p, p.is_alive())
 &lt;Process <span class="hljs-built_in">..</span>. initial&gt; <span class="hljs-literal">False</span>
 &gt;&gt;&gt; p.start()
 &gt;&gt;&gt; <span class="hljs-builtin-name">print</span>(p, p.is_alive())
 &lt;Process <span class="hljs-built_in">..</span>. started&gt; <span class="hljs-literal">True</span>
 &gt;&gt;&gt; p.terminate()
 &gt;&gt;&gt; time.sleep(0.1)
 &gt;&gt;&gt; <span class="hljs-builtin-name">print</span>(p, p.is_alive())
 &lt;Process <span class="hljs-built_in">..</span>. stopped <span class="hljs-attribute">exitcode</span>=-SIGTERM&gt; <span class="hljs-literal">False</span>
 &gt;&gt;&gt; p.exitcode == -signal.SIGTERM
 <span class="hljs-literal">True</span></code></pre></div>
<p>Now let's see what is stdout and stderr.</p>
<h2 id="stdout-and-stderr">stdout and stderr</h2>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">sys.stdin
sys.stdout
sys.stderr</pre><pre class="hljs"><code>sys.<span class="hljs-built_in">stdin</span>
sys.<span class="hljs-built_in">stdout</span>
sys.<span class="hljs-built_in">stderr</span></code></pre></div>
<ul>
<li>stdin is used for all interactive input (including calls to input());</li>
<li>stdout is used for the output of print() and expression statements and for the prompts of input();</li>
<li>The interpreter’s own prompts and its error messages go to stderr.</li>
</ul>
<p>There are just output streams... so now knowing this we can see the problem that we are trying to solve.</p>
<p><strong>Problem</strong></p>
<blockquote>
<p>Current implementation of [[ShellCommand]] splits stdout and stderr. In our project, we value chronological ordering more than stderr coloring. That's why we wanted to keep stdout and stderr in a single stream (as bash would do by default). You already have want_stdout and want_stderr options, so you offer some configuration in this reagard. Please implement a new option named e.g. merge_stderr or merge_streams which would not split streams when starting the process.</p>
</blockquote>
<p><img  class="center-img" src="{{ '/assets/encora/weekly/week10/args.png'}}" alt="Captura de Pantalla 2021-06-17 a la(s) 18.24.55.png"></p>
<p>As we can see these are options or parameters and we need ot create a new one.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">@util.deferredLocked('loglock')
   def addStdout(self, data):
       if self.collectStdout:
           self.stdout += data
       if self.stdioLogName is not None and self.stdioLogName in self.logs:
           self.logs[self.stdioLogName].addStdout(data)
       return defer.succeed(None)

   @util.deferredLocked('loglock')
   def addStderr(self, data):
       if self.collectStderr:
           self.stderr += data
       if self.stdioLogName is not None and self.stdioLogName in self.logs:
           self.logs[self.stdioLogName].addStderr(data)
       return defer.succeed(None)</pre><pre class="hljs"><code>@util.deferredLocked(<span class="hljs-string">&#x27;loglock&#x27;</span>)
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addStdout</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, data)</span></span>:
       <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">collectStdout:</span>
           <span class="hljs-keyword">self</span>.stdout += data
       <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stdioLogName is <span class="hljs-keyword">not</span> None <span class="hljs-keyword">and</span> <span class="hljs-keyword">self</span>.stdioLogName <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">logs:</span>
           <span class="hljs-keyword">self</span>.logs[<span class="hljs-keyword">self</span>.stdioLogName].addStdout(data)
       <span class="hljs-keyword">return</span> defer.succeed(None)

   @util.deferredLocked(<span class="hljs-string">&#x27;loglock&#x27;</span>)
   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addStderr</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, data)</span></span>:
       <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">collectStderr:</span>
           <span class="hljs-keyword">self</span>.stderr += data
       <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.stdioLogName is <span class="hljs-keyword">not</span> None <span class="hljs-keyword">and</span> <span class="hljs-keyword">self</span>.stdioLogName <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">logs:</span>
           <span class="hljs-keyword">self</span>.logs[<span class="hljs-keyword">self</span>.stdioLogName].addStderr(data)
       <span class="hljs-keyword">return</span> defer.succeed(None)</code></pre></div>
<p>As we can see here there are two different processes for running the stdout and the stderr, and we want to avoid that.</p>
<p>How can we achieve that? Let's research that.</p>
<h2 id="subprocess-class">Subprocess class</h2>
<p>The subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. This module intends to replace several older modules and functions:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">os.system
os.spawn*</pre><pre class="hljs"><code><span class="hljs-selector-tag">os</span><span class="hljs-selector-class">.system</span>
<span class="hljs-selector-tag">os</span><span class="hljs-selector-class">.spawn</span>*</code></pre></div>
<p>I was researching this class when I found that we can do achieve this with this class:</p>
<blockquote>
<p>If capture_output is true, stdout and stderr will be captured. When used, the internal Popen object is automatically created with stdout=PIPE and stderr=PIPE. The stdout and stderr arguments may not be supplied at the same time as capture_output. If you wish to capture and combine both streams into one, use stdout=PIPE and stderr=STDOUT instead of capture_output.</p>
</blockquote>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">subprocess.PIPE
Special value that can be used as the stdin, stdout or stderr argument to Popen and indicates that a pipe to the standard stream should be opened. Most useful with Popen.communicate().</pre><pre class="hljs"><code>subprocess.PIPE
Special <span class="hljs-built_in">value</span> that can be used <span class="hljs-keyword">as</span> <span class="hljs-keyword">the</span> <span class="hljs-keyword">stdin</span>, <span class="hljs-keyword">stdout</span> <span class="hljs-keyword">or</span> <span class="hljs-keyword">stderr</span> argument <span class="hljs-built_in">to</span> Popen <span class="hljs-keyword">and</span> indicates that <span class="hljs-keyword">a</span> pipe <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> standard stream should be opened. Most useful <span class="hljs-keyword">with</span> Popen.communicate().</code></pre></div>
<p>So now I think that takes 1 line to do the that:</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">subprocess.call(args, stderr=subprocess.STDOUT)</pre><pre class="hljs"><code>subprocess.call(args, <span class="hljs-attribute">stderr</span>=subprocess.STDOUT)</code></pre></div>
<p>This doesn't mean that the problem is solved, not we have to create an option and then test and see if this is really happening. But let's make sure at looking at the code of call.</p>
<div class="joplin-editable"><pre class="joplin-source" data-joplin-language="" data-joplin-source-open="```&#10;" data-joplin-source-close="&#10;```">subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, cwd=None, timeout=None, **other_popen_kwargs)</pre><pre class="hljs"><code>subprocess.call(args, *, <span class="hljs-attribute">stdin</span>=None, <span class="hljs-attribute">stdout</span>=None, <span class="hljs-attribute">stderr</span>=None, <span class="hljs-attribute">shell</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">cwd</span>=None, <span class="hljs-attribute">timeout</span>=None, **other_popen_kwargs)</code></pre></div>
<p>Run the command described by args. Wait for command to complete, then return the returncode attribute.</p>
<p>Now let's see subprocess.STDOUT</p>
<p>stdout<br>
Captured stdout from the child process. A bytes sequence, or a string if run() was called with an encoding, errors, or text=True. None if stdout was not captured.</p>
<p>If you ran the process with <code class="inline-code">stderr=subprocess.STDOUT</code>, stdout and stderr will be combined in this attribute, and stderr will be None.</p>
<p>Yeah maybe that's the solution we can have some conclusions.</p>
<p>Sometimes in systems, you have to decide, it's a trade-off between functionality and sometimes usability, in this case, it is crucial for the system to show the stdout and stderr in the stream because is more important the time than the visual color view.</p>




<br><br>
<p>Lastly the new technichal stuff that I learned.</p>
<br>
<h2>Technichal new stuff</h2>
<br>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/ts.png'}}" alt="how">
<br>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS1.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS2.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS3.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS4.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS5.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS6.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS7.png'}}" alt="how">
<img class="center-img" src="{{ '/assets/encora/weekly/week10/TS8.png'}}" alt="how">

<p>That's all... was a long week... let's keep going.</p>
<img class="center-img" src="{{ '/assets/encora/weekly/week10/zelda.png'}}" alt="how">
<br>
